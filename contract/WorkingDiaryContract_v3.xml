<?xml version="1.0" encoding="UTF-8"?>

<CSpec>
    <stype>1</stype>
    <idPath></idPath>
    <idName></idName>
    <iptFunc></iptFunc>
    <iptArgs>
    </iptArgs>
    <timeout>0</timeout>
    <secureContext>string</secureContext>
    <code>
        <![CDATA[
import java.text.SimpleDateFormat
import java.util.Date
import org.json4s._
import org.json4s.jackson.JsonMethods._
import rep.sc.contract._
import scalaj.http.{Http, HttpOptions, HttpRequest, HttpResponse}

/**
 * 用于提交工作日志的合约v3
 * 增加了合约跨网跨链测试
 */
class WorkingDiaryContract_v3 extends IContract{

    case class RequestGet(targetURL:String, paramName:String, paramValue:String, connTimeoutMs:Integer, readTimeoutMs:Integer)
    case class RequestPost(targetURL:String, params:Map[String, String])
    case class ReplaceCert(newPemCert:String, oldCertAddr:String)
    //case class Integral(userName:String, operator:Integer, value:Integer)
    case class WorkingDiary(userName:String, text:String)
    val INTEGRAL = "INTEGRAL_"
    val DIARY = "DIARY_"
    val URL = "http://192.168.21.14:8081/transaction/postTran";
    val CHAINCODEID = "5c10331c21d0b9279b2ae95ff018e22699eb301ba819fbcce8ed59835e8f934f"

    implicit val formats = DefaultFormats

    def init(ctx: ContractContext){
        println(s"tid: $ctx.t.txid")
    }

    // 获取当前时间
    def getDay():String={
        var now:Date = new Date()
        var  dateFormat:SimpleDateFormat = new SimpleDateFormat("yyyyMMdd")
        dateFormat.format( now )
    }

   /**
    * 工作日志上链
    * 约定：key = 用户名
    * 约定：value = 日志标题+日志内容
    * 约定：存入区块链的workingDiaryKey = key+当前系统时间
    * 说明：为防止人为修改入链时间，标题中的时间不允许后台创建，由合约自动创建
    */
    def workingDiaryProof(ctx: ContractContext, data:WorkingDiary):Object = {
        val currentDay = getDay()
        val workingDiaryKey = data.userName.concat(currentDay)
        println("workingDiaryKey:"+workingDiaryKey)
        val workLog = ctx.api.getVal(workingDiaryKey)
        println("workLog:"+workLog)
        println(workLog == null)
        // 方便测试，暂时放开每日提交一次限制
        //if( workLog != None && workLog != null){
        //    throw new Exception("今天日志已上链")
        //}
        ctx.api.setVal(workingDiaryKey, data.text)
        integralOperation(ctx, data.userName)
        "ok"
    }

   /**
    * 查询用户日志
    * 约定：diaryKey = userName+getDay()
    */
    def queryWorkingDiary(ctx: ContractContext, diaryKey: String):Object = {
        ctx.api.getVal(diaryKey).toString
    }


   /**
    * 积分操作
    * 约定：Integral.operator <= 表示“-”，反之表示“+”
    * 约定：Integral.userName 是用户的真实名字全拼+用户id
    * 约定：积分账户 = INTEGRAL + userName
    */
    def integralOperation(ctx: ContractContext, userName:String) = {
        val integralAccount = INTEGRAL.concat(userName)
        var oldIntegral = ctx.api.getVal(integralAccount)
        if (oldIntegral == null || oldIntegral == None){
            ctx.api.setVal(integralAccount, 1)
        } else {
            var integral:Integer = 1+oldIntegral.toString.toInt
            ctx.api.setVal(integralAccount, integral)
        }
    }

   /**
    * 积分查询
    * 约定：积分账户 = INTEGRAL + Integral.userName
    */
    def queryIntegral(ctx: ContractContext, userName: String):Object = {
        val integralAccount = INTEGRAL.concat(userName)
        ctx.api.getVal(integralAccount).toString
    }


   /**
    * 证书上链
    * @param ctx  合约上下文
    * @return
    */
    def certProof(ctx: ContractContext, data:Map[String,String]):Object = {
        var addr = ""
        for((k,v)<-data){
        ctx.api.check(ctx.t.cert.toStringUtf8,ctx.t)
            addr = ctx.api.signup(k,v)
        }
        addr
    }

   /**
    * 销毁证书
    * @param ctx  合约上下文
    * @param certAddr 证书短地址
    * @return
    */
    def destroyCert(ctx: ContractContext, certAddr: String): Object = {
        println(s"destroy cert->addr:$certAddr")
        ctx.api.check(ctx.t.cert.toStringUtf8,ctx.t)    //ctx中自带交易内容
        ctx.api.destroyCert(certAddr);
        "destory scuccess"
    }

   /**
    * 替换证书
    * @param ctx  合约上下文
    * @param oldCertAddr 旧证书短地址
    * @param newPemCert 新证书
    * @return
    */
    def replaceCert(ctx: ContractContext, data:ReplaceCert): Object = {
        val cert = data.newPemCert
        val addr = data.oldCertAddr
        ctx.api.check(ctx.t.cert.toStringUtf8,ctx.t)
        ctx.api.replaceCert(cert,addr);   // 返回短地址
    }

/********************************* 以下代码仅用于合约内部跨链调用测试 ********************************/

   /**
    * http.get - for testing
    * 发送GET请求
    */
    def sendGet(url:String, params:Map[String, String]):Any = {
        val request: HttpRequest = Http(URL)
        val response: HttpResponse[String] = request.params(params).asString
        response
    }

    def xmlData(idName:String, iptFunc:String, iptArgs:String):String = {
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"+
        "<CSpec>\n"+
        "<stype>2</stype>\n"+
        "<idPath></idPath>\n"+
        "<idName>"+ idName +"</idName>\n"+
        "<iptFunc>"+ iptFunc +"</iptFunc>\n"+
        "<iptArgs>\n"+  "\""+iptArgs+"\""  + "\n</iptArgs>\n"+
        "<timeout>0</timeout>\n"+
        "<secureContext>string</secureContext>\n"+
        "<code></code>\n"+
        "<ctype>2</ctype>\n"+
        "</CSpec>"
    }

   /**
    * http.post - for testing
    * 发送POST请求
    */
    def sendPost(url:String, data:String):HttpResponse[String] = {
        val result:HttpResponse[String] = Http(url).postData(data)
            .header("Content-Type", "application/xml")
            .header("Charset", "UTF-8")
            .option(HttpOptions.readTimeout(10000)).asString
        result
    }


   /**
    * 积分操作接口，用于跨网跨链测试
    */
    def addIntegral(ctx: ContractContext, userName:String):Object = {
        val integralAccount = INTEGRAL.concat(userName)
        var oldIntegral = ctx.api.getVal(integralAccount)
        if (oldIntegral == null || oldIntegral == None){
            ctx.api.setVal(integralAccount, 1)
        } else {
            var integral:Integer = 1+oldIntegral.toString.toInt
            ctx.api.setVal(integralAccount, integral)
        }
        "add integral success"
    }

   /**
    * 日志上链接口，用于跨网跨链测试
    */
    def putDiary(ctx: ContractContext, data:WorkingDiary):Object = {
        val xmlParam = xmlData(CHAINCODEID, "addIntegral", data.userName)
        val response = sendPost(URL,xmlParam)
            println("response.code:"+response.code)
        if (response.isServerError){
            throw new Exception("积分服务器错误")
        }
        if (response.isSuccess && response.code != 200){
            throw new Exception("积分请求参数错误")
        }
        if(response.code == 200){
            val currentDay = getDay()
            val workingDiaryKey = data.userName.concat(currentDay)
            println("workingDiaryKey:"+workingDiaryKey)
            val workLog = ctx.api.getVal(workingDiaryKey)
            println("workLog:"+workLog)
            ctx.api.setVal(workingDiaryKey, data.text)
        }
        "ok"
    }


    /**
    * 根据action,找到对应的method，并将传入的json字符串parse为method需要的传入参数
    */
    def onAction(ctx: ContractContext,action:String, sdata:String ):Object={
        val json = parse(sdata)

        action match {

            case "workingDiaryProof" =>
                println(s"workingDiaryProof")
                workingDiaryProof(ctx, json.extract[WorkingDiary])

            // 跨网跨链测试
            case "putDiary" =>
              println(s"putDiary")
              putDiary(ctx, json.extract[WorkingDiary])

            case "queryWorkingDiary" =>
                println(s"queryWorkingDiary")
                queryWorkingDiary(ctx, json.extract[String])

            // 跨网跨链测试
            case "addIntegral" =>
              println(s"addIntegral")
              addIntegral(ctx, json.extract[String])

            case "queryIntegral" =>
                println(s"queryIntegral")
                queryIntegral(ctx, json.extract[String])

            case "certProof" =>
                println(s"certProof")
                certProof(ctx, json.extract[Map[String,String]])

            case "destroyCert" =>
                println(s"destroyCert")
                destroyCert(ctx, json.extract[String])

            case "replaceCert" =>
                println(s"replaceCert")
                replaceCert(ctx, json.extract[ReplaceCert])
        }
    }
}
]]>
    </code>
    <ctype>1</ctype>
</CSpec>